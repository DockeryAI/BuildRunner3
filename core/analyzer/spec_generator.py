"""
PROJECT_SPEC Generator - Creates PROJECT_SPEC.md from codebase analysis.
"""

from pathlib import Path
from typing import Dict, List, Any
from datetime import datetime
from .codebase_analyzer import AnalysisResult


class SpecGenerator:
    """Generate PROJECT_SPEC.md from existing codebase"""

    def from_existing_code(self, analysis: AnalysisResult) -> str:
        """Generate PROJECT_SPEC.md content from analysis results"""

        # Infer project name from root directory
        project_name = Path(analysis.project_root).name

        spec_content = f"""# PROJECT_SPEC - {project_name}

**Generated from existing codebase**
**Date:** {datetime.now().strftime('%Y-%m-%d')}
**Location:** {analysis.project_root}

---

## Overview

{self._generate_overview(analysis)}

---

## Core Features

{self._generate_features(analysis)}

---

## Technical Architecture

**Languages:** {', '.join(analysis.languages) if analysis.languages else 'Not detected'}
**Frameworks:** {', '.join(analysis.frameworks) if analysis.frameworks else 'None detected'}
**Architecture Pattern:** {analysis.architecture}
**Database:** {analysis.database or 'Not detected'}

### Project Structure

```
{self._generate_structure(analysis)}
```

### Dependencies

{self._generate_dependencies(analysis)}

---

## API Endpoints

{self._generate_api_endpoints(analysis)}

---

## Testing Strategy

**Current Test Coverage:** ~{analysis.test_coverage:.1f}%
**Test Files:** {self._count_test_files(analysis)}

**Testing Approach:**
- Unit tests for core business logic
- Integration tests for API endpoints
- End-to-end tests for critical workflows
- Target coverage: 90%+

---

## Implementation Timeline

**Phase 1: Consolidation (Week 1-2)**
- Review and document existing features
- Fix critical bugs and technical debt
- Improve test coverage to 70%+

**Phase 2: Enhancement (Week 3-4)**
- Add missing features identified in analysis
- Optimize performance bottlenecks
- Improve error handling

**Phase 3: Polish (Week 5-6)**
- Complete documentation
- Achieve 90%+ test coverage
- Production readiness

---

## Success Metrics

**Code Quality:**
- Test coverage: {analysis.test_coverage:.1f}% → 90%+
- Zero critical security vulnerabilities
- All linting rules passing

**Performance:**
- API response time < 200ms
- Database query optimization
- Memory usage optimization

**Stability:**
- 99.9% uptime
- Zero data loss
- Automated backups

---

## Next Steps

1. ✅ **Code Analysis Complete** - {analysis.file_count} files, {analysis.lines_of_code:,} lines
2. ⏳ **Review Features** - Validate extracted features
3. ⏳ **Add Missing Tests** - Improve coverage from {analysis.test_coverage:.1f}%
4. ⏳ **Document APIs** - Complete API documentation
5. ⏳ **Production Deploy** - Deploy to production environment

---

## Notes

This PROJECT_SPEC was automatically generated from your existing codebase.
Please review and adjust as needed.

**Detected Capabilities:**
- {len(analysis.features)} features extracted from code
- {len(analysis.api_endpoints)} API endpoints found
- {len(analysis.languages)} programming language(s)
- {len(analysis.frameworks)} framework(s) detected

**Recommendations:**
- Consider adding integration tests
- Document all API endpoints
- Add error handling for edge cases
- Implement monitoring and logging

---

*Generated by BuildRunner 3.2 - Code Analysis Tool*
"""

        return spec_content

    def _generate_overview(self, analysis: AnalysisResult) -> str:
        """Generate project overview"""
        project_name = Path(analysis.project_root).name

        if analysis.frameworks:
            framework_desc = f"built with {', '.join(analysis.frameworks)}"
        elif analysis.languages:
            framework_desc = f"written in {', '.join(analysis.languages)}"
        else:
            framework_desc = "software project"

        return f"""{project_name} is a {framework_desc} using {analysis.architecture} architecture.

**Project Statistics:**
- **Files:** {analysis.file_count}
- **Lines of Code:** {analysis.lines_of_code:,}
- **Languages:** {', '.join(analysis.languages) if analysis.languages else 'Multiple'}
- **Test Coverage:** ~{analysis.test_coverage:.1f}%

**Key Capabilities:**
{self._list_capabilities(analysis)}"""

    def _list_capabilities(self, analysis: AnalysisResult) -> str:
        """List key project capabilities"""
        capabilities = []

        if analysis.api_endpoints:
            capabilities.append(f"- RESTful API with {len(analysis.api_endpoints)} endpoints")

        if analysis.database:
            capabilities.append(f"- Data persistence with {analysis.database}")

        # Group features by type
        feature_types = {}
        for feature in analysis.features:
            ftype = feature.get("type", "general")
            feature_types[ftype] = feature_types.get(ftype, 0) + 1

        for ftype, count in feature_types.items():
            capabilities.append(f"- {count} {ftype} feature(s)")

        return "\n".join(capabilities) if capabilities else "- Core application functionality"

    def _generate_features(self, analysis: AnalysisResult) -> str:
        """Generate features section"""
        if not analysis.features:
            return """### Feature 1: Core Functionality
**Priority:** Critical
**Status:** Implemented

**Description:** Main application features (details to be documented)

**Requirements:**
- Existing functionality
- Maintain backward compatibility
- Add comprehensive tests

**Acceptance Criteria:**
- [ ] All existing functionality works
- [ ] Tests pass
- [ ] Documentation complete"""

        features_text = []
        for i, feature in enumerate(analysis.features[:10], 1):  # Limit to top 10
            name = feature.get("name", f"Feature {i}")
            ftype = feature.get("type", "general")
            file_loc = feature.get("file", "Unknown")

            features_text.append(
                f"""### Feature {i}: {name}
**Priority:** High
**Type:** {ftype}
**Location:** `{file_loc}`

**Description:** Existing feature detected in codebase

**Requirements:**
- Maintain current functionality
- Add comprehensive tests
- Document behavior

**Acceptance Criteria:**
- [ ] Feature works as expected
- [ ] Tests cover main scenarios
- [ ] Documentation exists
"""
            )

        return "\n".join(features_text)

    def _generate_structure(self, analysis: AnalysisResult) -> str:
        """Generate project structure overview"""
        root = Path(analysis.project_root)
        structure = []

        try:
            for item in sorted(root.iterdir()):
                if item.is_dir() and not item.name.startswith("."):
                    structure.append(f"{item.name}/")
        except:
            structure.append("(Project structure)")

        return "\n".join(structure[:15])  # Show top 15 directories

    def _generate_dependencies(self, analysis: AnalysisResult) -> str:
        """Generate dependencies section"""
        if not analysis.dependencies:
            return "No dependencies file detected."

        deps_text = []
        for lang, packages in analysis.dependencies.items():
            deps_text.append(f"**{lang.capitalize()}:**")
            for pkg in packages[:10]:  # Show top 10
                deps_text.append(f"- {pkg}")
            if len(packages) > 10:
                deps_text.append(f"- ... and {len(packages) - 10} more")

        return "\n".join(deps_text)

    def _generate_api_endpoints(self, analysis: AnalysisResult) -> str:
        """Generate API endpoints section"""
        if not analysis.api_endpoints:
            return "No API endpoints detected."

        endpoints_text = ["**Detected Endpoints:**\n"]
        for endpoint in analysis.api_endpoints[:20]:  # Limit to 20
            method = endpoint.get("method", "GET")
            path = endpoint.get("path", "/")
            file_loc = endpoint.get("file", "Unknown")
            endpoints_text.append(f"- `{method} {path}` - `{file_loc}`")

        if len(analysis.api_endpoints) > 20:
            endpoints_text.append(f"\n... and {len(analysis.api_endpoints) - 20} more endpoints")

        return "\n".join(endpoints_text)

    def _count_test_files(self, analysis: AnalysisResult) -> int:
        """Count test files"""
        test_count = 0
        for feature in analysis.features:
            if "test" in feature.get("file", "").lower():
                test_count += 1
        return test_count
